- TYPE: fetch 
  Inputs:
    feature_buffer_base_address: 0     # feature of some nodes to be scattered in buffer
    number_of_features:                             # Width of each node feature @Marc, number? or Byte? or bitwidth
    number_of_nodes:                            # Number of nodes available in buffer location
    edge_info_array: Could be read from a FIFO Queue? Basically contains all target addresses of a scatter operation. @Kai How many Scatter can we do in parallel ? Is there an upper limit? @Marc, do you mean how many nodes can be fetched in one cycle?
  Outputs:
    feature_buffer_base_address: Virtual Target Tensor Address in Buffer
  Hardware: Fetch
  comment: (Virtual Instruction) Defined on a tile, Generates addresses based on edge information in Fetch unit and fetch each node at a time. We plan to optimize this every time through instruction fusion.

- TYPE: store 
  Inputs:
    buffer_base_address: 0 / Virtual Target Tensor Address in Buffer   # Use virtual address to store what is fetched by fetch inst.
    number_of_features: 
    number_of_nodes:  #Also works for edges
  Outputs:
    ddr_base_address:                    
  Hardware: Store                       # Memory Interface Controller 
  comment: Buffer to DDR, Defined on a feature or a tile (1 node/edge or more?). We always read X elements from buffer (defined by architecture)

- TYPE: load-tile
  Argument:
  Inputs:
    tile_info_array: #From load-graph
      type : enum {node,edge} # node is dense, edge is sparse 
      ddr_base_address: (DDR)
      number_of_features : Width of each node feature vector
      number_of_nodes : Number of nodes or edges to read in a tile
  Outputs:
    buffer_base_address: (Buffer)
  Hardware Target: Load Memory Interface Controller 
  comment: DDR to Buffer
  
load-graph
Inputs:
  address : base address to edge list
  num_edges: Length of edge list
  num_nodes: Number of unique nodes per edge list
Outputs:
  tile_info_array: #list of commands to load-tile unit with inputs described above
  edge_info_array: #list of commands to fetch unit with inputs described above
Hardware Target: Graph Tiling Controller ? 
comment: Prepare loading data from DDR to Buffer. Instruction generating control signals to load nodes and edges in a tiled manner

load-weight
Inputs:
  ddr_base_address: # (DDR)
  number_of_features : #Width of each node feature vector
  number_of_nodes : #Number of nodes to read in a tile
Outputs:
  buffer_base_address (buffer)
comment: DDR to Buffer. Assumption weights are always stored in a way such that we are able to access them efficiently 
Hardware Target: Load Memory Interface Controller 

comp-tensor-algebra
Argument:
  operator: type #Defined as formula
Inputs:
  a_buffer_base_address:
  a_dimension_array: #List of dimensions of buffer a, e.g. [number_of_nodes,number_of_features]
  b_buffer_base_address:
  b_dimension_array: #List of dimensions of buffer a, e.g. [number_of_nodes,number_of_features]
Outputs:
  c_buffer_base_address:
  c_dimension_array: #Is calcu
comment: Buffer to Buffer
Hardware Target: Algebra Computation Unit 
